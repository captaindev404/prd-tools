#!/bin/bash

################################################################################
# File Upload Penetration Test Script
#
# Purpose: Test file upload security vulnerabilities in Gentil Feedback platform
# Target: /api/feedback/upload endpoint
# Author: Security Validation Agent (A4)
# Date: 2025-10-09
#
# Usage:
#   chmod +x scripts/security/file-upload-pentest.sh
#   ./scripts/security/file-upload-pentest.sh <BASE_URL> <AUTH_TOKEN>
#
# Example:
#   ./scripts/security/file-upload-pentest.sh http://localhost:3000 "Bearer eyJhbGc..."
#
# Requirements:
#   - curl
#   - xxd (for hex dumps)
#   - jq (for JSON parsing)
#
# Exit Codes:
#   0 - All tests passed (no vulnerabilities found)
#   1 - Vulnerabilities detected
#   2 - Setup error (missing dependencies, invalid arguments)
################################################################################

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test counters
TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0
VULNERABILITIES_FOUND=0

# Configuration
BASE_URL="${1:-http://localhost:3000}"
AUTH_TOKEN="${2:-}"
UPLOAD_ENDPOINT="${BASE_URL}/api/feedback/upload"
TEMP_DIR=$(mktemp -d)

# Cleanup on exit
trap "rm -rf ${TEMP_DIR}" EXIT

################################################################################
# Helper Functions
################################################################################

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[PASS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[FAIL]${NC} $1"
}

log_vuln() {
    echo -e "${RED}[VULNERABILITY]${NC} $1"
    ((VULNERABILITIES_FOUND++))
}

check_dependencies() {
    local missing_deps=()

    command -v curl >/dev/null 2>&1 || missing_deps+=("curl")
    command -v xxd >/dev/null 2>&1 || missing_deps+=("xxd")
    command -v jq >/dev/null 2>&1 || missing_deps+=("jq")

    if [ ${#missing_deps[@]} -ne 0 ]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        log_info "Install with: brew install ${missing_deps[*]}"
        exit 2
    fi
}

run_test() {
    local test_name="$1"
    local test_function="$2"

    ((TESTS_RUN++))
    log_info "Running: ${test_name}"

    if $test_function; then
        ((TESTS_PASSED++))
        log_success "${test_name}"
    else
        ((TESTS_FAILED++))
        log_error "${test_name}"
    fi

    echo ""
}

upload_file() {
    local file_path="$1"
    local expected_status="${2:-201}"

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${file_path}" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    if [ "$http_code" = "$expected_status" ]; then
        echo "$body"
        return 0
    else
        echo "Expected status $expected_status, got $http_code"
        echo "Response: $body"
        return 1
    fi
}

################################################################################
# Test 1: Authentication Enforcement
################################################################################

test_auth_required() {
    log_info "Testing authentication requirement..."

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)

    if [ "$http_code" = "401" ]; then
        log_success "Unauthenticated request correctly rejected (401)"
        return 0
    else
        log_vuln "CRITICAL: Upload endpoint allows unauthenticated access (got ${http_code}, expected 401)"
        return 1
    fi
}

################################################################################
# Test 2: Rate Limiting
################################################################################

test_rate_limiting() {
    log_info "Testing upload rate limiting (10 requests/min)..."

    local rate_limited=false

    for i in {1..12}; do
        # Create a small test file
        echo "Test content $i" > "${TEMP_DIR}/rate-test-${i}.txt"

        local response=$(curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Authorization: ${AUTH_TOKEN}" \
            -F "file=@${TEMP_DIR}/rate-test-${i}.txt" \
            "${UPLOAD_ENDPOINT}")

        local http_code=$(echo "$response" | tail -n1)

        if [ "$http_code" = "429" ]; then
            rate_limited=true
            log_success "Rate limit enforced after ${i} requests"
            break
        fi
    done

    if [ "$rate_limited" = true ]; then
        return 0
    else
        log_vuln "HIGH: Rate limiting not working - sent 12 uploads without 429 response"
        return 1
    fi
}

################################################################################
# Test 3: File Size Limits
################################################################################

test_file_size_limit() {
    log_info "Testing file size limits (10MB per file)..."

    # Create an 11MB file
    dd if=/dev/zero of="${TEMP_DIR}/large-file.bin" bs=1024 count=11264 2>/dev/null

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/large-file.bin" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    if [ "$http_code" = "400" ] || [ "$http_code" = "413" ]; then
        log_success "Oversized file rejected (${http_code})"
        return 0
    else
        log_vuln "HIGH: File size limit not enforced - 11MB file accepted (got ${http_code})"
        return 1
    fi
}

test_total_size_limit() {
    log_info "Testing total upload size limit (50MB)..."

    # Create 6 files of 9MB each (54MB total)
    for i in {1..6}; do
        dd if=/dev/zero of="${TEMP_DIR}/batch-${i}.bin" bs=1024 count=9216 2>/dev/null
    done

    local curl_args=(-s -w "\n%{http_code}" -X POST -H "Authorization: ${AUTH_TOKEN}")

    for i in {1..6}; do
        curl_args+=(-F "files=@${TEMP_DIR}/batch-${i}.bin")
    done

    local response=$(curl "${curl_args[@]}" "${UPLOAD_ENDPOINT}")
    local http_code=$(echo "$response" | tail -n1)

    if [ "$http_code" = "400" ] || [ "$http_code" = "413" ]; then
        log_success "Total size limit enforced (${http_code})"
        return 0
    else
        log_vuln "MEDIUM: Total size limit not enforced - 54MB batch accepted (got ${http_code})"
        return 1
    fi
}

test_file_count_limit() {
    log_info "Testing file count limit (5 files max)..."

    # Create 7 small files
    for i in {1..7}; do
        echo "Test content $i" > "${TEMP_DIR}/count-test-${i}.txt"
    done

    local curl_args=(-s -w "\n%{http_code}" -X POST -H "Authorization: ${AUTH_TOKEN}")

    for i in {1..7}; do
        curl_args+=(-F "files=@${TEMP_DIR}/count-test-${i}.txt")
    done

    local response=$(curl "${curl_args[@]}" "${UPLOAD_ENDPOINT}")
    local http_code=$(echo "$response" | tail -n1)

    if [ "$http_code" = "400" ]; then
        log_success "File count limit enforced (${http_code})"
        return 0
    else
        log_vuln "MEDIUM: File count limit not enforced - 7 files accepted (got ${http_code})"
        return 1
    fi
}

################################################################################
# Test 4: File Type Validation
################################################################################

test_executable_rejection() {
    log_info "Testing executable file rejection (.exe, .sh, .bat)..."

    # Create fake executable with .exe extension
    echo "#!/bin/bash\necho 'malicious code'" > "${TEMP_DIR}/malware.exe"

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/malware.exe" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)

    if [ "$http_code" = "400" ]; then
        log_success "Executable file rejected (${http_code})"
        return 0
    else
        log_vuln "CRITICAL: Executable file accepted - potential RCE risk (got ${http_code})"
        return 1
    fi
}

test_double_extension_attack() {
    log_info "Testing double extension attack (.pdf.exe)..."

    # Create file with double extension
    echo "Fake PDF content" > "${TEMP_DIR}/document.pdf.exe"

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/document.pdf.exe" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)

    if [ "$http_code" = "400" ]; then
        log_success "Double extension attack blocked (${http_code})"
        return 0
    else
        log_vuln "HIGH: Double extension file accepted (got ${http_code})"
        return 1
    fi
}

test_mime_type_spoofing() {
    log_info "Testing MIME type spoofing (fake JPEG)..."

    # Create a text file with JPEG extension
    echo "This is not a JPEG" > "${TEMP_DIR}/fake.jpg"

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/fake.jpg;type=image/jpeg" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    if [ "$http_code" = "400" ]; then
        if echo "$body" | grep -q "signature"; then
            log_success "MIME spoofing detected via signature verification (${http_code})"
            return 0
        else
            log_warning "File rejected but signature verification unclear"
            return 0
        fi
    else
        log_vuln "HIGH: MIME type spoofing not detected - fake JPEG accepted (got ${http_code})"
        return 1
    fi
}

test_magic_byte_validation() {
    log_info "Testing magic byte signature validation..."

    # Create a file that claims to be JPEG but has wrong magic bytes
    printf '\x00\x00\x00\x00' > "${TEMP_DIR}/wrong-signature.jpg"

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/wrong-signature.jpg;type=image/jpeg" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)

    if [ "$http_code" = "400" ]; then
        log_success "Magic byte validation working - wrong signature rejected (${http_code})"
        return 0
    else
        log_vuln "HIGH: Magic byte validation failed - wrong signature accepted (got ${http_code})"
        return 1
    fi
}

################################################################################
# Test 5: Filename Security
################################################################################

test_directory_traversal() {
    log_info "Testing directory traversal in filename..."

    echo "Test content" > "${TEMP_DIR}/../../etc/passwd"

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/../../etc/passwd" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    # Check if file was sanitized or rejected
    if echo "$body" | jq -e '.files[0].storedName' 2>/dev/null | grep -q "etc/passwd"; then
        log_vuln "CRITICAL: Directory traversal not sanitized - path preserved in stored name"
        return 1
    else
        log_success "Directory traversal sanitized or rejected (${http_code})"
        return 0
    fi
}

test_null_byte_injection() {
    log_info "Testing null byte injection in filename..."

    # Create file with null byte in name (if filesystem allows)
    echo "Test content" > "${TEMP_DIR}/test.txt"

    # Try to upload with null byte in form data
    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/test.txt;filename=malicious%00.jpg" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)

    if [ "$http_code" = "400" ] || [ "$http_code" = "201" ]; then
        log_success "Null byte injection handled (${http_code})"
        return 0
    else
        log_warning "Unexpected response to null byte injection (${http_code})"
        return 0
    fi
}

test_special_characters_in_filename() {
    log_info "Testing special characters in filename..."

    echo "Test content" > "${TEMP_DIR}/test.txt"

    # Filename with XSS attempt
    local malicious_filename="<script>alert('xss')</script>.txt"

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/test.txt;filename=${malicious_filename}" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    # Check if special characters were sanitized
    if echo "$body" | jq -e '.files[0].originalName' 2>/dev/null | grep -q "<script>"; then
        log_warning "Special characters preserved in originalName (potential XSS if rendered unsafely)"
        return 0
    else
        log_success "Special characters sanitized in filename"
        return 0
    fi
}

################################################################################
# Test 6: GDPR & Privacy
################################################################################

test_pii_in_filename() {
    log_info "Testing PII detection in filename..."

    echo "Test content" > "${TEMP_DIR}/test.txt"

    # Filename with email
    local pii_filename="john.doe@clubmed.com-report.pdf"

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/test.txt;filename=${pii_filename}" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    # This is an expected failure (PII detection not implemented yet)
    if echo "$body" | jq -e '.files[0].originalName' 2>/dev/null | grep -q "@clubmed.com"; then
        log_warning "PII (email) not sanitized from filename - see H-FILE-001 in audit report"
        return 0  # Not failing test as it's a known limitation
    else
        log_success "PII sanitized from filename"
        return 0
    fi
}

################################################################################
# Test 7: Storage Security
################################################################################

test_public_directory_access() {
    log_info "Testing if uploaded files are accessible without authentication..."

    # First, upload a test file
    echo "Sensitive data" > "${TEMP_DIR}/public-test.txt"

    local upload_response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/public-test.txt" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$upload_response" | tail -n1)

    if [ "$http_code" != "201" ]; then
        log_warning "Could not upload test file for public access test"
        return 0
    fi

    local body=$(echo "$upload_response" | sed '$d')
    local file_url=$(echo "$body" | jq -r '.files[0].url' 2>/dev/null)

    if [ -z "$file_url" ] || [ "$file_url" = "null" ]; then
        log_warning "No file URL returned, cannot test public access"
        return 0
    fi

    # Try to access the file without authentication
    local access_response=$(curl -s -w "\n%{http_code}" "${BASE_URL}${file_url}")
    local access_code=$(echo "$access_response" | tail -n1)

    if [ "$access_code" = "200" ]; then
        log_vuln "CRITICAL: Uploaded files are publicly accessible without authentication (C-STOR-001)"
        echo "  URL: ${BASE_URL}${file_url}"
        return 1
    elif [ "$access_code" = "401" ] || [ "$access_code" = "403" ]; then
        log_success "Files require authentication to access (${access_code})"
        return 0
    else
        log_warning "Unexpected response when testing public access (${access_code})"
        return 0
    fi
}

################################################################################
# Test 8: Error Handling & Information Disclosure
################################################################################

test_error_information_leakage() {
    log_info "Testing for sensitive information in error messages..."

    # Try to upload an invalid file
    local response=$(curl -s \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@/dev/null" \
        "${UPLOAD_ENDPOINT}")

    # Check if error message contains sensitive paths
    if echo "$response" | grep -qE "(/home/|/var/|/usr/|C:\\\\|Users\\\\)"; then
        log_vuln "MEDIUM: Error message contains filesystem paths"
        echo "$response" | head -n 5
        return 1
    fi

    # Check for stack traces
    if echo "$response" | grep -qE "(at .+\(.+:\d+:\d+\)|Error: .+ at .+)"; then
        log_vuln "MEDIUM: Error message contains stack trace"
        return 1
    fi

    log_success "Error messages do not leak sensitive information"
    return 0
}

################################################################################
# Test 9: Content Validation
################################################################################

test_svg_xml_bomb() {
    log_info "Testing SVG XML bomb detection..."

    # Create a billion laughs attack SVG
    cat > "${TEMP_DIR}/bomb.svg" <<'EOF'
<?xml version="1.0"?>
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
]>
<svg xmlns="http://www.w3.org/2000/svg">
  <text>&lol3;</text>
</svg>
EOF

    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: ${AUTH_TOKEN}" \
        -F "file=@${TEMP_DIR}/bomb.svg;type=image/svg+xml" \
        "${UPLOAD_ENDPOINT}")

    local http_code=$(echo "$response" | tail -n1)

    # SVG is not in allowed file types, so it should be rejected
    if [ "$http_code" = "400" ]; then
        log_success "SVG files rejected (not in allowed types)"
        return 0
    else
        log_warning "SVG upload attempt got unexpected response (${http_code})"
        return 0
    fi
}

################################################################################
# Test 10: Concurrent Upload Attack
################################################################################

test_concurrent_uploads() {
    log_info "Testing concurrent upload handling..."

    # Create test file
    echo "Concurrent test" > "${TEMP_DIR}/concurrent.txt"

    # Launch 5 uploads in parallel
    local pids=()
    for i in {1..5}; do
        curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Authorization: ${AUTH_TOKEN}" \
            -F "file=@${TEMP_DIR}/concurrent.txt" \
            "${UPLOAD_ENDPOINT}" > "${TEMP_DIR}/concurrent-${i}.log" 2>&1 &
        pids+=($!)
    done

    # Wait for all to complete
    for pid in "${pids[@]}"; do
        wait "$pid"
    done

    # Check results
    local success_count=0
    for i in {1..5}; do
        if grep -q "201" "${TEMP_DIR}/concurrent-${i}.log"; then
            ((success_count++))
        fi
    done

    if [ $success_count -eq 5 ]; then
        log_success "All concurrent uploads processed correctly"
        return 0
    elif [ $success_count -gt 0 ]; then
        log_warning "Some concurrent uploads succeeded ($success_count/5)"
        return 0
    else
        log_error "All concurrent uploads failed"
        return 1
    fi
}

################################################################################
# Main Execution
################################################################################

main() {
    echo "╔════════════════════════════════════════════════════════════════════════╗"
    echo "║          File Upload Security Penetration Test Suite                  ║"
    echo "║          Target: ${UPLOAD_ENDPOINT}"
    echo "╚════════════════════════════════════════════════════════════════════════╝"
    echo ""

    # Pre-flight checks
    log_info "Checking dependencies..."
    check_dependencies

    if [ -z "$AUTH_TOKEN" ]; then
        log_warning "No authentication token provided. Some tests will be skipped."
        log_info "Usage: $0 <BASE_URL> <AUTH_TOKEN>"
        echo ""
    fi

    log_info "Using base URL: ${BASE_URL}"
    log_info "Temporary directory: ${TEMP_DIR}"
    echo ""

    # Run test suites
    echo "═══════════════════════════════════════════════════════════════════════"
    echo "Test Suite 1: Authentication & Authorization"
    echo "═══════════════════════════════════════════════════════════════════════"
    run_test "AUTH-001: Authentication required" test_auth_required

    if [ -n "$AUTH_TOKEN" ]; then
        echo "═══════════════════════════════════════════════════════════════════════"
        echo "Test Suite 2: Rate Limiting"
        echo "═══════════════════════════════════════════════════════════════════════"
        run_test "RATE-001: Upload rate limiting" test_rate_limiting

        echo "═══════════════════════════════════════════════════════════════════════"
        echo "Test Suite 3: File Size & Count Limits"
        echo "═══════════════════════════════════════════════════════════════════════"
        run_test "SIZE-001: Per-file size limit (10MB)" test_file_size_limit
        run_test "SIZE-002: Total upload size limit (50MB)" test_total_size_limit
        run_test "SIZE-003: File count limit (5 files)" test_file_count_limit

        echo "═══════════════════════════════════════════════════════════════════════"
        echo "Test Suite 4: File Type Validation"
        echo "═══════════════════════════════════════════════════════════════════════"
        run_test "TYPE-001: Executable file rejection" test_executable_rejection
        run_test "TYPE-002: Double extension attack" test_double_extension_attack
        run_test "TYPE-003: MIME type spoofing" test_mime_type_spoofing
        run_test "TYPE-004: Magic byte validation" test_magic_byte_validation

        echo "═══════════════════════════════════════════════════════════════════════"
        echo "Test Suite 5: Filename Security"
        echo "═══════════════════════════════════════════════════════════════════════"
        run_test "FILE-001: Directory traversal prevention" test_directory_traversal
        run_test "FILE-002: Null byte injection" test_null_byte_injection
        run_test "FILE-003: Special characters sanitization" test_special_characters_in_filename

        echo "═══════════════════════════════════════════════════════════════════════"
        echo "Test Suite 6: GDPR & Privacy"
        echo "═══════════════════════════════════════════════════════════════════════"
        run_test "GDPR-001: PII detection in filename" test_pii_in_filename

        echo "═══════════════════════════════════════════════════════════════════════"
        echo "Test Suite 7: Storage Security"
        echo "═══════════════════════════════════════════════════════════════════════"
        run_test "STOR-001: Public directory access control" test_public_directory_access

        echo "═══════════════════════════════════════════════════════════════════════"
        echo "Test Suite 8: Error Handling"
        echo "═══════════════════════════════════════════════════════════════════════"
        run_test "ERR-001: Information leakage in errors" test_error_information_leakage

        echo "═══════════════════════════════════════════════════════════════════════"
        echo "Test Suite 9: Content Validation"
        echo "═══════════════════════════════════════════════════════════════════════"
        run_test "CONTENT-001: SVG XML bomb detection" test_svg_xml_bomb

        echo "═══════════════════════════════════════════════════════════════════════"
        echo "Test Suite 10: Concurrency & Performance"
        echo "═══════════════════════════════════════════════════════════════════════"
        run_test "PERF-001: Concurrent upload handling" test_concurrent_uploads
    else
        log_warning "Skipping authenticated tests (no token provided)"
    fi

    # Summary
    echo ""
    echo "╔════════════════════════════════════════════════════════════════════════╗"
    echo "║                         Test Summary                                   ║"
    echo "╚════════════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "Tests Run:        ${TESTS_RUN}"
    echo -e "Tests Passed:     ${GREEN}${TESTS_PASSED}${NC}"
    echo -e "Tests Failed:     ${RED}${TESTS_FAILED}${NC}"
    echo -e "Vulnerabilities:  ${RED}${VULNERABILITIES_FOUND}${NC}"
    echo ""

    if [ $VULNERABILITIES_FOUND -gt 0 ]; then
        echo -e "${RED}╔════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║  WARNING: ${VULNERABILITIES_FOUND} VULNERABILITIES DETECTED                                  ║${NC}"
        echo -e "${RED}║  Review the audit report: docs/security/FILE-UPLOAD-SECURITY-AUDIT.md ║${NC}"
        echo -e "${RED}╚════════════════════════════════════════════════════════════════════════╝${NC}"
        exit 1
    elif [ $TESTS_FAILED -gt 0 ]; then
        echo -e "${YELLOW}╔════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${YELLOW}║  Some tests failed but no critical vulnerabilities detected          ║${NC}"
        echo -e "${YELLOW}╚════════════════════════════════════════════════════════════════════════╝${NC}"
        exit 0
    else
        echo -e "${GREEN}╔════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║  All security tests passed!                                            ║${NC}"
        echo -e "${GREEN}╚════════════════════════════════════════════════════════════════════════╝${NC}"
        exit 0
    fi
}

# Run main function
main
