use anyhow::Result;
use std::fs;
use std::path::PathBuf;

const POST_COMMIT_HOOK: &str = r#"#!/bin/bash
# PRD Tool - Auto-complete tasks from commit messages
# Generated by: prd install-git-hook
# DO NOT EDIT THIS FILE MANUALLY

# Get the commit message
commit_msg=$(git log -1 --pretty=%B)

# Extract task IDs using various patterns
task_ids=""

# Pattern 1: TASK-XXX
if [[ $commit_msg =~ TASK-([0-9]+) ]]; then
    task_ids="$task_ids ${BASH_REMATCH[1]}"
fi

# Pattern 2: Task #XXX (case insensitive)
while [[ $commit_msg =~ [Tt]ask[[:space:]]*#([0-9]+) ]]; do
    task_ids="$task_ids ${BASH_REMATCH[1]}"
    # Remove the matched part to find more
    commit_msg="${commit_msg/${BASH_REMATCH[0]}/}"
done

# Pattern 3: Complete/Finish/Done XXX
if [[ $commit_msg =~ [Cc]omplete[d]?[[:space:]]*:?[[:space:]]*#?([0-9]+) ]]; then
    task_ids="$task_ids ${BASH_REMATCH[1]}"
fi

if [[ $commit_msg =~ [Ff]inish(es|ed)?[[:space:]]*:?[[:space:]]*#?([0-9]+) ]]; then
    task_ids="$task_ids ${BASH_REMATCH[2]}"
fi

if [[ $commit_msg =~ [Dd]one[[:space:]]*:?[[:space:]]*#?([0-9]+) ]]; then
    task_ids="$task_ids ${BASH_REMATCH[1]}"
fi

# Pattern 4: Closes/Fixes #XXX
if [[ $commit_msg =~ [Cc]lose[s]?[[:space:]]*#([0-9]+) ]]; then
    task_ids="$task_ids ${BASH_REMATCH[1]}"
fi

if [[ $commit_msg =~ [Ff]ix(es|ed)?[[:space:]]*#([0-9]+) ]]; then
    task_ids="$task_ids ${BASH_REMATCH[2]}"
fi

# Pattern 5: [XXX] at start
if [[ $commit_msg =~ ^\[([0-9]+)\] ]]; then
    task_ids="$task_ids ${BASH_REMATCH[1]}"
fi

# Remove duplicates and process
task_ids=$(echo "$task_ids" | tr ' ' '\n' | sort -u | grep -v '^$')

if [ -z "$task_ids" ]; then
    # No tasks found, exit silently
    exit 0
fi

for task_id in $task_ids; do
    echo "🔍 Detected task #$task_id in commit, marking complete..."

    # Try to mark complete (silently fail if task doesn't exist)
    prd complete "$task_id" --auto 2>/dev/null

    if [ $? -eq 0 ]; then
        echo "✓ Task #$task_id marked complete"
    fi
done
"#;

/// Git hook manager for installing and managing post-commit hooks
pub struct GitHookManager {
    repo_path: PathBuf,
}

impl GitHookManager {
    /// Create a new hook manager
    ///
    /// # Arguments
    /// * `repo_path` - Path to the git repository root
    pub fn new(repo_path: PathBuf) -> Self {
        Self { repo_path }
    }

    /// Install the post-commit hook
    ///
    /// # Returns
    /// * `Ok(())` - Hook installed successfully
    /// * `Err(_)` - Installation failed
    pub fn install(&self) -> Result<()> {
        let hook_path = self.repo_path.join(".git/hooks/post-commit");

        // Check if git directory exists
        if !self.repo_path.join(".git").exists() {
            return Err(anyhow::anyhow!(
                "Not a git repository: {}",
                self.repo_path.display()
            ));
        }

        // Check if hook already exists
        if hook_path.exists() {
            let existing = fs::read_to_string(&hook_path)?;
            if existing.contains("PRD Tool") {
                return Err(anyhow::anyhow!("PRD git hook already installed"));
            }

            // Backup existing hook
            let backup_path = hook_path.with_extension("backup");
            fs::copy(&hook_path, &backup_path)?;
            println!("⚠ Backed up existing hook to {}", backup_path.display());
        }

        // Ensure hooks directory exists
        let hooks_dir = self.repo_path.join(".git/hooks");
        fs::create_dir_all(&hooks_dir)?;

        // Write hook
        fs::write(&hook_path, POST_COMMIT_HOOK)?;

        // Make executable (Unix only)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&hook_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&hook_path, perms)?;
        }

        println!("✓ Git hook installed at {}", hook_path.display());
        println!("  Tasks will be auto-completed on commit");
        println!("\nExample commit messages that will trigger auto-completion:");
        println!("  - Complete TASK-033: Add validation");
        println!("  - Finish task #50");
        println!("  - TASK-057: Implement feature");
        println!("  - Closes #42");
        println!("  - [54] Fix bug");

        Ok(())
    }

    /// Uninstall the post-commit hook
    ///
    /// # Returns
    /// * `Ok(())` - Hook uninstalled successfully
    /// * `Err(_)` - Uninstallation failed
    pub fn uninstall(&self) -> Result<()> {
        let hook_path = self.repo_path.join(".git/hooks/post-commit");

        if !hook_path.exists() {
            return Err(anyhow::anyhow!("No git hook found"));
        }

        let content = fs::read_to_string(&hook_path)?;
        if !content.contains("PRD Tool") {
            return Err(anyhow::anyhow!(
                "Not a PRD tool hook (would not remove non-PRD hook)"
            ));
        }

        fs::remove_file(&hook_path)?;
        println!("✓ Git hook removed");

        // Restore backup if exists
        let backup_path = hook_path.with_extension("backup");
        if backup_path.exists() {
            fs::rename(&backup_path, &hook_path)?;
            println!("  Restored previous hook from backup");

            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                let mut perms = fs::metadata(&hook_path)?.permissions();
                perms.set_mode(0o755);
                fs::set_permissions(&hook_path, perms)?;
            }
        }

        Ok(())
    }

    /// Show git hook status
    ///
    /// # Returns
    /// * `Ok(())` - Status displayed successfully
    /// * `Err(_)` - Error checking status
    pub fn status(&self) -> Result<()> {
        let hook_path = self.repo_path.join(".git/hooks/post-commit");

        if !hook_path.exists() {
            println!("Git hook: Not installed");
            return Ok(());
        }

        let content = fs::read_to_string(&hook_path)?;
        if content.contains("PRD Tool") {
            println!("Git hook: Installed ✓");
            println!("Location: {}", hook_path.display());
            println!("Tasks will be auto-completed on commit");
        } else {
            println!("Git hook: Different hook installed (not PRD)");
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_git_hook_content() {
        // Verify hook script contains expected patterns
        assert!(POST_COMMIT_HOOK.contains("TASK-"));
        assert!(POST_COMMIT_HOOK.contains("prd complete"));
        assert!(POST_COMMIT_HOOK.contains("#!/bin/bash"));
    }

    #[test]
    fn test_git_hook_has_all_patterns() {
        // Verify all task detection patterns are present
        assert!(POST_COMMIT_HOOK.contains("TASK-"));
        assert!(POST_COMMIT_HOOK.contains("[Tt]ask"));
        assert!(POST_COMMIT_HOOK.contains("[Cc]omplete"));
        assert!(POST_COMMIT_HOOK.contains("[Ff]inish"));
        assert!(POST_COMMIT_HOOK.contains("[Cc]lose"));
        assert!(POST_COMMIT_HOOK.contains("[Ff]ix"));
        assert!(POST_COMMIT_HOOK.contains(r"^\["));
    }
}
